<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ for Robotics - Topic Guide</title>
    <style>
        /* Base styles for all screen sizes (mobile-first) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #fff;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s ease;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .search-container {
            position: relative;
            margin-bottom: 25px;
            animation: fadeInDown 0.8s ease 0.2s both;
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            border-radius: 25px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .category-section {
            margin-bottom: 40px;
        }

        .category-title {
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
            opacity: 0.9;
        }

        .topic-grid {
            display: grid;
            gap: 15px;
            margin-bottom: 30px;
        }

        .topic-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            animation: fadeInUp 0.8s ease both;
        }

        .topic-card:hover,
        .topic-card:active {
            transform: translateY(-3px);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .topic-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }

        .topic-subtitle {
            font-size: 0.95rem;
            opacity: 0.8;
            margin-bottom: 12px;
        }

        .topic-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .topic-tag {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .difficulty {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 10px;
        }

        .beginner {
            background: rgba(46, 204, 113, 0.3);
            color: #2ecc71;
            border: 1px solid #2ecc71;
        }

        .intermediate {
            background: rgba(241, 196, 15, 0.3);
            color: #f1c40f;
            border: 1px solid #f1c40f;
        }

        .advanced {
            background: rgba(231, 76, 60, 0.3);
            color: #e74c3c;
            border: 1px solid #e74c3c;
        }

        /* Page view styles */
        .page-view {
            display: none;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .page-header {
            display: flex;
            align-items: center;
            margin-bottom: 30px;
            gap: 15px;
        }

        .back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 12px 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-3px);
        }

        .page-title {
            font-size: 2rem;
            font-weight: 700;
            color: #ecf0f1;
        }

        .code-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 4px solid #3498db;
        }

        .code-section h3 {
            font-size: 1.4rem;
            color: #3498db;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .code-section h4 {
            font-size: 1.1rem;
            color: #e74c3c;
            margin: 15px 0 10px 0;
            font-weight: 500;
        }

        .code-block {
            background: #1e1e1e;
            border-radius: 12px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid #444;
            color: #f8f8f2;
            position: relative;
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        .highlight {
            background: linear-gradient(120deg, rgba(46, 204, 113, 0.2) 0%, rgba(52, 152, 219, 0.2) 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2ecc71;
        }

        .warning {
            background: linear-gradient(120deg, rgba(231, 76, 60, 0.2) 0%, rgba(192, 57, 43, 0.2) 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #e74c3c;
        }

        .tip {
            background: linear-gradient(120deg, rgba(241, 196, 15, 0.2) 0%, rgba(243, 156, 18, 0.2) 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #f1c40f;
        }

        /* Syntax highlighting */
        .keyword {
            color: #569cd6;
            font-weight: bold;
        }

        .string {
            color: #ce9178;
        }

        .comment {
            color: #6a9955;
            font-style: italic;
        }

        .function {
            color: #dcdcaa;
            font-weight: bold;
        }

        .number {
            color: #b5cea8;
        }

        .type {
            color: #4ec9b0;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        .show {
            display: block !important;
        }

        /* Animations */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive Media Queries */
        @media (min-width: 480px) {
            .topic-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            }
        }

        @media (min-width: 768px) {
            .topic-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 1024px) {
            .topic-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>

<body>
    <div id="mainView" class="container">
        <div class="header">
            <h1>C++ for Robotics</h1>
            <p>Topic-Based Code Reference</p>
        </div>
        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search for functions, sensors, or concepts..."
                id="searchInput">
        </div>
        <div class="category-section">
            <h2 class="category-title">🔧 Basic Setup</h2>
            <div class="topic-grid">
                <div class="topic-card" data-topic="setup"
                    data-search-content="Robot Setup & Configuration Beginner Set up motors, sensors, and basic project structure motors ports configuration brain Every robot program starts with these includes and global device definitions: #include "
                    vex.h" using namespace vex; // A global instance of vex::brain used for printing to the brain screen
                    vex::brain Brain; Define your motors with the correct ports and directions: // Drive motors motor
                    leftMotor=motor(PORT1, false); // PORT1, not reversed motor rightMotor=motor(PORT7, true); // PORT7,
                    reversed // Arm motors motor leftArm=motor(PORT3, false); motor rightArm=motor(PORT9, true); //
                    Motor groups (for multiple motors working together) motor_group leftDrive(leftFrontMotor,
                    leftBackMotor); motor_group rightDrive(rightFrontMotor, rightBackMotor); Define all your sensors: //
                    Sensors gyro myGyro=gyro(PORT10); inertial inertialSensor=inertial(PORT11); optical
                    lineSensor=optical(PORT12); bumper frontBumper=bumper(PORT13); controller controller1=controller();
                    Here's a complete setup you can copy and modify: #include "vex.h" using namespace vex; // Brain
                    instance vex::brain Brain; // Motor definitions - CHANGE PORTS TO MATCH YOUR ROBOT motor
                    leftMotor=motor(PORT1, false); // Left drive motor motor rightMotor=motor(PORT10, true); // Right
                    drive motor (reversed) motor leftArm=motor(PORT3, false); // Left arm motor motor
                    rightArm=motor(PORT8, true); // Right arm motor (reversed) // Sensor definitions - CHANGE PORTS TO
                    MATCH YOUR ROBOT inertial inertialSensor=inertial(PORT15); optical lineSensor=optical(PORT16);
                    bumper frontBumper=bumper(PORT17); controller controller1=controller(); // Your functions go here
                    int main() { // Your main program starts here return 0; } ⚠️ Important Notes Port Numbers: You MUST
                    change the port numbers to match your actual robot wiring Motor Direction: Use true to reverse a
                    motor if it spins the wrong way Sensor Calibration: Some sensors (like inertial) need calibration
                    before use">
                    <div class="topic-title">Robot Setup & Configuration <span
                            class="difficulty beginner">Beginner</span></div>
                    <div class="topic-subtitle">Set up motors, sensors, and basic project structure</div>
                    <div class="topic-tags">
                        <span class="topic-tag">motors</span>
                        <span class="topic-tag">ports</span>
                        <span class="topic-tag">configuration</span>
                        <span class="topic-tag">brain</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="debugging"
                    data-search-content="Debugging & Brain Display Beginner Monitor sensor values and debug your robot brain screen threads sensor values debugging Displaying Sensor Values on the Brain Screen This function creates a separate thread to continuously display sensor values, which is extremely useful for debugging. // Define a global instance of a gyro sensor first gyro myGyro = gyro(PORT9); void brainDisplay() { while(true) { Brain.Screen.clearScreen(); Brain.Screen.printAt(1,30,LeftMotor %f, leftMotor.position(degrees)); Brain.Screen.printAt(1,50,RightArm %f, rightArm.position(degrees)); Brain.Screen.printAt(1,70,Gyro %f, myGyro.rotation(degrees)); wait(10, msec); } } int main() { thread t(brainDisplay); // Your main program code goes here... } Why use a thread? Running this function in a separate thread prevents it from blocking your main program logic, so your robot can drive and perform tasks while the display updates in the background.">
                    <div class="topic-title">Debugging & Brain Display <span class="difficulty beginner">Beginner</span>
                    </div>
                    <div class="topic-subtitle">Monitor sensor values and debug your robot</div>
                    <div class="topic-tags">
                        <span class="topic-tag">brain screen</span>
                        <span class="topic-tag">threads</span>
                        <span class="topic-tag">sensor values</span>
                        <span class="topic-tag">debugging</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="category-section">
            <h2 class="category-title">🚀 Movement Functions</h2>
            <div class="topic-grid">
                <div class="topic-card" data-topic="basic-movement"
                    data-search-content="Basic Forward/Backward Beginner Time-based and distance-based movement forward backward position sensors while loops Basic Drive Forward This function drives forward until the motor's encoder reaches a specified distance. Be aware that this can cause overshooting due to inertia. void driveForwardBasic(int distance) { leftMotor.setPosition(0, deg); while(leftMotor.position(degrees) < distance) { leftMotor.spin(forward, 100, pct); rightMotor.spin(forward, 100, pct); } leftMotor.stop(); rightMotor.stop(); } Basic Drive Reverse A simple function to drive backward using negative position values. void driveReverse(int distance) { leftMotor.setPosition(0, deg); while(-leftMotor.position(degrees) < distance) { leftMotor.spin(reverse, 100, pct); rightMotor.spin(reverse, 100, pct); } leftMotor.stop(); rightMotor.stop(); } Moving until a Bumper is Pressed This demonstrates using a boolean condition in a while loop to stop the robot. int main() { thread t(brainDisplay); while (leftMotor.position(degrees) < 5000 && frontBumper.pressing() == 0) { leftMotor.spin(forward, 50, pct); rightMotor.spin(forward, 50, pct); } leftMotor.stop(); rightMotor.stop(); }">
                    <div class="topic-title">Basic Forward/Backward <span class="difficulty beginner">Beginner</span>
                    </div>
                    <div class="topic-subtitle">Time-based and distance-based movement</div>
                    <div class="topic-tags">
                        <span class="topic-tag">forward</span>
                        <span class="topic-tag">backward</span>
                        <span class="topic-tag">position sensors</span>
                        <span class="topic-tag">while loops</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="turning"
                    data-search-content="Turn Functions Beginner Left/right turns using gyro sensors gyro inertial turns degrees Turning Right with Gyro This uses a while loop to turn the robot right until the gyro sensor's rotation is less than the target angle. void turnRight(int angle) { myGyro.resetRotation(); while(myGyro.rotation(degrees) < angle) { leftMotor.spin(forward, 50, pct); rightMotor.spin(reverse, 50, pct); } leftMotor.stop(); rightMotor.stop(); } Turning Left with Gyro This uses a while loop to turn the robot left until the gyro sensor's rotation is greater than the target angle. void turnLeft(int angle) { myGyro.resetRotation(); while(myGyro.rotation(degrees) > -angle) { leftMotor.spin(reverse, 50, pct); rightMotor.spin(forward, 50, pct); } leftMotor.stop(); rightMotor.stop(); } Note: Make sure your gyro sensor is properly calibrated before use to get accurate turns.">
                    <div class="topic-title">Turn Functions <span class="difficulty beginner">Beginner</span></div>
                    <div class="topic-subtitle">Left/right turns using gyro sensors</div>
                    <div class="topic-tags">
                        <span class="topic-tag">gyro</span>
                        <span class="topic-tag">inertial</span>
                        <span class="topic-tag">turns</span>
                        <span class="topic-tag">degrees</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="drive-straight"
                    data-search-content="Drive Straight Intermediate Gyro-based error correction for straight driving error correction gyro correction kp tuning Gyro-based Drive Straight Function This function uses a simple proportional control (kp) to correct the robot's heading while driving straight, preventing it from veering off course. void driveStraight(int distance, double kp) { inertial inertialSensor = inertial(PORT11); inertialSensor.setHeading(0, degrees); leftMotor.setPosition(0, degrees); while (leftMotor.position(degrees) < distance) { double error = inertialSensor.heading(degrees); double correction = error * kp; leftMotor.spin(forward, 50 - correction, pct); rightMotor.spin(forward, 50 + correction, pct); } leftMotor.stop(); rightMotor.stop(); } Tuning kp: The value of kp (proportional constant) needs to be tuned for your specific robot. A value that is too high will cause over-correction and make the robot wiggle. A value that is too low will not correct the drift enough.">
                    <div class="topic-title">Drive Straight <span class="difficulty intermediate">Intermediate</span>
                    </div>
                    <div class="topic-subtitle">Gyro-based error correction for straight driving</div>
                    <div class="topic-tags">
                        <span class="topic-tag">error correction</span>
                        <span class="topic-tag">gyro correction</span>
                        <span class="topic-tag">kp tuning</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="pid-control"
                    data-search-content="PID Control Advanced Proportional control and Bang Bang methods proportional bang bang error precision Bang-Bang Control A simple control method that drives at full speed and then slows down near the target to prevent overshooting. void driveForwardBangBang(int distance) { leftMotor.setPosition(0, deg); while(leftMotor.position(degrees) < distance * 0.80) { leftMotor.spin(forward, 100, pct); rightMotor.spin(forward, 100, pct); } while(leftMotor.position(degrees) < distance) { leftMotor.spin(forward, 10, pct); rightMotor.spin(forward, 10, pct); } leftMotor.stop(); rightMotor.stop(); } Overshooting: Bang-Bang can still overshoot, especially with heavier robots or on slick surfaces. The 80% threshold may need to be adjusted. Proportional Control (Ramping) This code ramps the motor speed up as it starts and ramps it down as it approaches the target, leading to smoother movement. void driveForwardProp(int distance) { leftMotor.setPosition(0, degrees); while(leftMotor.position(degrees) < distance) { int speed = 0; if (leftMotor.position(degrees) < 100 && leftMotor.position(degrees) < distance * 0.5) { speed = leftMotor.position(degrees) + 1; } else { speed = distance - leftMotor.position(degrees); } leftMotor.spin(forward, speed, pct); rightMotor.spin(forward, speed, pct); } leftMotor.stop(); rightMotor.stop(); }">
                    <div class="topic-title">PID Control <span class="difficulty advanced">Advanced</span></div>
                    <div class="topic-subtitle">Proportional control and Bang Bang methods</div>
                    <div class="topic-tags">
                        <span class="topic-tag">proportional</span>
                        <span class="topic-tag">bang bang</span>
                        <span class="topic-tag">error</span>
                        <span class="topic-tag">precision</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="category-section">
            <h2 class="category-title">📡 Sensors</h2>
            <div class="topic-grid">
                <div class="topic-card" data-topic="gyro-sensor"
                    data-search-content="Gyro/Inertial Sensor Intermediate Setup, calibration, and usage for turns calibration rotation heading compass Calibrating the Inertial Sensor You must calibrate your inertial sensor before using it in your code to ensure accurate readings. int main() { // A global instance of vex::brain used for printing to the brain screen vex::brain Brain; // Define a global inertial sensor instance inertial inertialSensor = inertial(PORT15); thread t(brainDisplay); // Assumes you have a brainDisplay function inertialSensor.calibrate(); // Wait until the calibration is complete while(inertialSensor.isCalibrating()) { wait(100, msec); } // Your main program logic starts here... } Reading the Sensor To use the sensor's value, you can access its heading or rotation attribute. // Get the current heading in degrees double currentHeading = inertialSensor.heading(degrees); // Print the value to the Brain screen Brain.Screen.printAt(1, 70, Heading: %f, currentHeading);">
                    <div class="topic-title">Gyro/Inertial Sensor <span
                            class="difficulty intermediate">Intermediate</span></div>
                    <div class="topic-subtitle">Setup, calibration, and usage for turns</div>
                    <div class="topic-tags">
                        <span class="topic-tag">calibration</span>
                        <span class="topic-tag">rotation</span>
                        <span class="topic-tag">heading</span>
                        <span class="topic-tag">compass</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="optical-sensor"
                    data-search-content="Optical/Light Sensor Beginner Line following and color detection line following brightness color sensor light Line Following A simple line-following function that uses an optical sensor's brightness value to determine if the robot is on or off the line. void goForwardLines(int numberToGoTo) { int numberSeen = 0; while(numberSeen < numberToGoTo) { while(lineSensor.brightness() > 30) { leftMotor.spin(forward, 75, pct); rightMotor.spin(forward, 75, pct); } while(lineSensor.brightness() < 30) { leftMotor.spin(forward, 75, pct); rightMotor.spin(forward, 75, pct); } numberSeen++; } leftMotor.stop(); rightMotor.stop(); } Brightness Threshold: The value 30 is a placeholder. You need to test your sensor's brightness values on and off the line to find the correct threshold for your setup.">
                    <div class="topic-title">Optical/Light Sensor <span class="difficulty beginner">Beginner</span>
                    </div>
                    <div class="topic-subtitle">Line following and color detection</div>
                    <div class="topic-tags">
                        <span class="topic-tag">line following</span>
                        <span class="topic-tag">brightness</span>
                        <span class="topic-tag">color sensor</span>
                        <span class="topic-tag">light</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="bumper-sensor"
                    data-search-content="Bumper Sensor Beginner Collision detection and touch sensing collision touch pressing wall following Using a Bumper Sensor Bumper sensors are excellent for detecting collisions or for basic touch-based logic. The pressing() method returns a boolean (true/false) value. // Go forward until the bumper is pressed void driveUntilBumper() { bumper frontBumper = bumper(PORT13); while(frontBumper.pressing() == false) { leftMotor.spin(forward, 50, pct); rightMotor.spin(forward, 50, pct); } leftMotor.stop(); rightMotor.stop(); }">
                    <div class="topic-title">Bumper Sensor <span class="difficulty beginner">Beginner</span></div>
                    <div class="topic-subtitle">Collision detection and touch sensing</div>
                    <div class="topic-tags">
                        <span class="topic-tag">collision</span>
                        <span class="topic-tag">touch</span>
                        <span class="topic-tag">pressing</span>
                        <span class="topic-tag">wall following</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="category-section">
            <h2 class="category-title">🎮 Driver Control</h2>
            <div class="topic-grid">
                <div class="topic-card" data-topic="tank-drive"
                    data-search-content="Tank Drive Beginner Each joystick controls one side of the robot controller joystick tank drive left right Basic Tank Drive This code allows each joystick on the controller to control one side of the robot, providing independent control of the left and right sides. void tankDrive() { while(true) { leftMotor.spin(forward, Controller1.AxisA.position(), percent); rightMotor.spin(forward, Controller1.AxisD.position(), percent); wait(10, msec); } }">
                    <div class="topic-title">Tank Drive <span class="difficulty beginner">Beginner</span></div>
                    <div class="topic-subtitle">Each joystick controls one side of the robot</div>
                    <div class="topic-tags">
                        <span class="topic-tag">controller</span>
                        <span class="topic-tag">joystick</span>
                        <span class="topic-tag">tank drive</span>
                        <span class="topic-tag">left right</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="arcade-drive"
                    data-search-content="Arcade Drive Intermediate Single stick drive and turn control single stick arcade drive turn mixing Basic Arcade Drive Arcade drive uses a single joystick for both forward/backward and turning motion, which can be more intuitive for some users. void splitDrive() { while(true) { leftMotor.spin(forward, Controller1.AxisA.position() + Controller1.AxisC.position(), pct); rightMotor.spin(forward, Controller1.AxisA.position() - Controller1.AxisC.position(), pct); wait(10, msec); } } How it works: The speed for each motor is calculated by adding or subtracting the values from two different joystick axes (one for forward/backward, one for turning).">
                    <div class="topic-title">Arcade Drive <span class="difficulty intermediate">Intermediate</span>
                    </div>
                    <div class="topic-subtitle">Single stick drive and turn control</div>
                    <div class="topic-tags">
                        <span class="topic-tag">single stick</span>
                        <span class="topic-tag">arcade</span>
                        <span class="topic-tag">drive turn</span>
                        <span class="topic-tag">mixing</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="arm-control"
                    data-search-content="Arm Control Beginner Button-based arm movement with proper logic buttons arms else if hold brake Using Buttons for Arm Control This is a robust way to control an arm using button presses, with else if statements to ensure only one action happens at a time. void userControl() { while(true) { if(Controller1.ButtonRUp.pressing()) { rightArm.spin(forward, 50, pct); leftArm.spin(forward, 50, pct); } else if (Controller1.ButtonRDown.pressing()) { rightArm.spin(reverse, 50, pct); leftArm.spin(reverse, 50, pct); } else { leftArm.stop(hold); rightArm.stop(hold); } wait(10, msec); } } Common Mistake: Using two separate if statements instead of if/else if can cause the motors to stop and hold as soon as the button is released, even if the other button is still pressed.">
                    <div class="topic-title">Arm Control <span class="difficulty beginner">Beginner</span></div>
                    <div class="topic-subtitle">Button-based arm movement with proper logic</div>
                    <div class="topic-tags">
                        <span class="topic-tag">buttons</span>
                        <span class="topic-tag">arms</span>
                        <span class="topic-tag">else if</span>
                        <span class="topic-tag">hold brake</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="category-section">
            <h2 class="category-title">🎯 Advanced Topics</h2>
            <div class="topic-grid">
                <div class="topic-card" data-topic="inches-conversion"
                    data-search-content="Inches to Degrees Intermediate Convert real distances to motor rotations circumference wheel diameter distance conversion Converting Distance to Motor Rotations This helper function allows you to use real-world measurements (inches) to control your robot's movement. You must know your wheel's diameter to use this. // Wheel diameter in inches const double WHEEL_DIAMETER = 4.0; // Circumference formula: C = πd const double WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * M_PI; // A motor's rotation is 360 degrees. double inchesToDegrees(double distanceInches) { double distance = (distanceInches / WHEEL_CIRCUMFERENCE) * 360; return distance; } Using the function: Call the function like this: driveForward(inchesToDegrees(24)); to drive exactly 24 inches.">
                    <div class="topic-title">Inches to Degrees <span class="difficulty intermediate">Intermediate</span>
                    </div>
                    <div class="topic-subtitle">Convert real distances to motor rotations</div>
                    <div class="topic-tags">
                        <span class="topic-tag">circumference</span>
                        <span class="topic-tag">wheel diameter</span>
                        <span class="topic-tag">distance</span>
                        <span class="topic-tag">conversion</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="turn-to-heading"
                    data-search-content="Turn to Heading Advanced Absolute positioning with angle wrapping absolute heading angle wrapping compass helper functions Helper Function: Angle Wrapping This function normalizes an angle to a 0-360 degree range. This is critical for preventing issues with the gyro sensor values when turning past 360 degrees. double wrapAngle(double angle) { while (angle > 360) { angle -= 360; } while (angle < 0) { angle += 360; } return angle; } Turn to Heading Function This is an advanced function that uses the wrapped angle and a proportional constant (kp) to turn to an absolute heading on the field. void turnToHeading(double targetHeading) { double kp = 0.3; targetHeading = wrapAngle(targetHeading); while (fabs(inertialSensor.heading(degrees) - targetHeading) > 2.0) { double error = inertialSensor.heading(degrees) - targetHeading; double speed = error * kp; leftMotor.spin(forward, speed, pct); rightMotor.spin(reverse, speed, pct); } leftMotor.stop(brake); rightMotor.stop(brake); }">
                    <div class="topic-title">Turn to Heading <span class="difficulty advanced">Advanced</span></div>
                    <div class="topic-subtitle">Absolute positioning with angle wrapping</div>
                    <div class="topic-tags">
                        <span class="topic-tag">absolute heading</span>
                        <span class="topic-tag">angle wrapping</span>
                        <span class="topic-tag">compass</span>
                        <span class="topic-tag">helper functions</span>
                    </div>
                </div>
                <div class="topic-card" data-topic="competition-template"
                    data-search-content="Competition Template Advanced Official VEX competition code structure competition autonomous pre auton user control Official Competition Code Structure All VEX competition programs must be built using this template. The field control system will call autonomous() and usercontrol() at the appropriate times during the match. #include "
                    vex.h" using namespace vex; // Define your motors and sensors here... void pre_auton() { // Code to
                    run before autonomous starts (e.g., sensor calibration) } void autonomous() { // Code to run during
                    the 15-second autonomous period } void usercontrol() { // Code to run during the driver control
                    period } int main() { Competition.autonomous(autonomous); Competition.drivercontrol(usercontrol);
                    pre_auton(); while(true) { wait(100, msec); } } Important: You must use this competition template in
                    order to pass inspection and participate in a VRC competition.">
                    <div class="topic-title">Competition Template <span class="difficulty advanced">Advanced</span>
                    </div>
                    <div class="topic-subtitle">Official VEX competition code structure</div>
                    <div class="topic-tags">
                        <span class="topic-tag">competition</span>
                        <span class="topic-tag">autonomous</span>
                        <span class="topic-tag">pre auton</span>
                        <span class="topic-tag">user control</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="page-setup" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Robot Setup & Configuration</h1>
        </div>
        <div class="code-section">
            <h3>1. Basic Project Structure</h3>
            <p>Every robot program starts with these includes and global device definitions:</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">#include</span> <span class="string">"vex.h"</span>
<span class="keyword">using namespace</span> vex;
<span class="comment">// A global instance of vex::brain used for printing to the brain screen</span>
vex::<span class="type">brain</span> Brain;</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>2. Motor Setup</h3>
            <p>Define your motors with the correct ports and directions:</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment">// Drive motors</span>
<span class="keyword">motor</span> <span class="function">leftMotor</span> = <span class="function">motor</span>(PORT1, <span class="keyword">false</span>);  <span class="comment">// PORT1, not reversed</span>
<span class="keyword">motor</span> <span class="function">rightMotor</span> = <span class="function">motor</span>(PORT7, <span class="keyword">true</span>);   <span class="comment">// PORT7, reversed</span>
<span class="comment">// Arm motors</span>
<span class="keyword">motor</span> <span class="function">leftArm</span> = <span class="function">motor</span>(PORT3, <span class="keyword">false</span>);
<span class="keyword">motor</span> <span class="function">rightArm</span> = <span class="function">motor</span>(PORT9, <span class="keyword">true</span>);
<span class="comment">// Motor groups (for multiple motors working together)</span>
<span class="keyword">motor_group</span> <span class="function">leftDrive</span>(<span class="function">leftFrontMotor</span>, <span class="function">leftBackMotor</span>);
<span class="keyword">motor_group</span> <span class="function">rightDrive</span>(<span class="function">rightFrontMotor</span>, <span class="function">rightBackMotor</span>);</pre>
            </div>
            <div class="tip">
                <strong>Port Numbers:</strong> Change PORT1, PORT7, etc. to match where your motors are actually plugged
                in. The <code>true</code>/<code>false</code> parameter reverses motor direction if needed.
            </div>
        </div>
        <div class="code-section">
            <h3>3. Sensor Setup</h3>
            <p>Define all your sensors:</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment">// Sensors</span>
<span class="type">gyro</span> <span class="function">myGyro</span> = <span class="function">gyro</span>(PORT10);
<span class="type">inertial</span> <span class="function">inertialSensor</span> = <span class="function">inertial</span>(PORT11);
<span class="type">optical</span> <span class="function">lineSensor</span> = <span class="function">optical</span>(PORT12);
<span class="type">bumper</span> <span class="function">frontBumper</span> = <span class="function">bumper</span>(PORT13);
<span class="type">controller</span> <span class="function">controller1</span> = <span class="function">controller</span>();</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>4. Complete Setup Template</h3>
            <p>Here's a complete setup you can copy and modify:</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">#include</span> <span class="string">"vex.h"</span>
<span class="keyword">using namespace</span> vex;
<span class="comment">// Brain instance</span>
vex::<span class="type">brain</span> Brain;
<span class="comment">// Motor definitions - CHANGE PORTS TO MATCH YOUR ROBOT</span>
<span class="keyword">motor</span> <span class="function">leftMotor</span> = <span class="function">motor</span>(PORT1, <span class="keyword">false</span>);   <span class="comment">// Left drive motor</span>
<span class="keyword">motor</span> <span class="function">rightMotor</span> = <span class="function">motor</span>(PORT10, <span class="keyword">true</span>);   <span class="comment">// Right drive motor (reversed)</span>
<span class="keyword">motor</span> <span class="function">leftArm</span> = <span class="function">motor</span>(PORT3, <span class="keyword">false</span>);     <span class="comment">// Left arm motor</span>
<span class="keyword">motor</span> <span class="function">rightArm</span> = <span class="function">motor</span>(PORT8, <span class="keyword">true</span>);     <span class="comment">// Right arm motor (reversed)</span>
<span class="comment">// Sensor definitions - CHANGE PORTS TO MATCH YOUR ROBOT</span>
<span class="type">inertial</span> <span class="function">inertialSensor</span> = <span class="function">inertial</span>(PORT15);
<span class="type">optical</span> <span class="function">lineSensor</span> = <span class="function">optical</span>(PORT16);
<span class="type">bumper</span> <span class="function">frontBumper</span> = <span class="function">bumper</span>(PORT17);
<span class="type">controller</span> <span class="function">controller1</span> = <span class="function">controller</span>();
<span class="comment">// Your functions go here</span>
<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// Your main program starts here</span>
    <span class="keyword">return</span> <span class="number">0</span>;
}</pre>
            </div>
        </div>
        <div class="warning">
            <h4>⚠️ Important Notes</h4>
            <ul>
                <li><strong>Port Numbers:</strong> You MUST change the port numbers to match your actual robot wiring
                </li>
                <li><strong>Motor Direction:</strong> Use <code>true</code> to reverse a motor if it spins the wrong way
                </li>
                <li><strong>Sensor Calibration:</strong> Some sensors (like inertial) need calibration before use</li>
            </ul>
        </div>
    </div>
    <div id="page-debugging" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Debugging & Brain Display</h1>
        </div>
        <div class="code-section">
            <h3>Displaying Sensor Values on the Brain Screen</h3>
            <p>This function creates a separate thread to continuously display sensor values, which is extremely useful
                for debugging.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment">// Define a global instance of a gyro sensor first</span>
<span class="type">gyro</span> <span class="function">myGyro</span> = <span class="function">gyro</span>(PORT9);

<span class="keyword">void</span> <span class="function">brainDisplay</span>() {
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        Brain.Screen.clearScreen();
        Brain.Screen.printAt(1,30,<span class="string">"LeftMotor %f"</span>, leftMotor.position(degrees));
        Brain.Screen.printAt(1,50,<span class="string">"RightArm %f"</span>, rightArm.position(degrees));
        Brain.Screen.printAt(1,70,<span class="string">"Gyro %f"</span>, myGyro.rotation(degrees));
        wait(10, msec);
    }
}

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">thread</span> t(<span class="function">brainDisplay</span>);
    <span class="comment">// Your main program code goes here...</span>
}</pre>
            </div>
            <div class="tip">
                <strong>Why use a thread?</strong> Running this function in a separate thread prevents it from blocking
                your main program logic, so your robot can drive and perform tasks while the display updates in the
                background.
            </div>
        </div>
    </div>
    <div id="page-basic-movement" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Basic Forward/Backward</h1>
        </div>
        <div class="code-section">
            <h3>Basic Drive Forward</h3>
            <p>This function drives forward until the motor's encoder reaches a specified distance. Be aware that this
                can cause overshooting due to inertia.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveForwardBasic</span>(<span class="keyword">int</span> distance) {
    leftMotor.setPosition(0, deg);
    <span class="keyword">while</span>(leftMotor.position(degrees) < distance) {
        leftMotor.spin(forward, 100, pct);
        rightMotor.spin(forward, 100, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>Basic Drive Reverse</h3>
            <p>A simple function to drive backward using negative position values.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveReverse</span>(<span class="keyword">int</span> distance) {
    leftMotor.setPosition(0, deg);
    <span class="keyword">while</span>(-leftMotor.position(degrees) < distance) {
        leftMotor.spin(reverse, 100, pct);
        rightMotor.spin(reverse, 100, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>Moving until a Bumper is Pressed</h3>
            <p>This demonstrates using a boolean condition in a `while` loop to stop the robot.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">int</span> <span class="function">main</span>() {
    <span class="keyword">thread</span> t(<span class="function">brainDisplay</span>);
    <span class="keyword">while</span> (leftMotor.position(degrees) < 5000 && frontBumper.pressing() == <span class="number">0</span>) {
        leftMotor.spin(forward, 50, pct);
        rightMotor.spin(forward, 50, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
    </div>
    <div id="page-turning" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Turn Functions</h1>
        </div>
        <div class="code-section">
            <h3>Turning Right with Gyro</h3>
            <p>This uses a `while` loop to turn the robot right until the gyro sensor's rotation is less than the target
                angle.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">turnRight</span>(<span class="keyword">int</span> angle) {
    myGyro.resetRotation();
    <span class="keyword">while</span>(myGyro.rotation(degrees) < angle) {
        leftMotor.spin(forward, 50, pct);
        rightMotor.spin(reverse, 50, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>Turning Left with Gyro</h3>
            <p>This uses a `while` loop to turn the robot left until the gyro sensor's rotation is greater than the
                target angle.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">turnLeft</span>(<span class="keyword">int</span> angle) {
    myGyro.resetRotation();
    <span class="keyword">while</span>(myGyro.rotation(degrees) > -angle) {
        leftMotor.spin(reverse, 50, pct);
        rightMotor.spin(forward, 50, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
        <div class="warning">
            <strong>Note:</strong> Make sure your gyro sensor is properly calibrated before use to get accurate turns.
        </div>
    </div>
    <div id="page-drive-straight" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Drive Straight</h1>
        </div>
        <div class="code-section">
            <h3>Gyro-based Drive Straight Function</h3>
            <p>This function uses a simple proportional control (`kp`) to correct the robot's heading while driving
                straight, preventing it from veering off course.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveStraight</span>(<span class="keyword">int</span> distance, <span class="keyword">double</span> kp) {
    <span class="type">inertial</span> <span class="function">inertialSensor</span> = <span class="function">inertial</span>(PORT11);
    inertialSensor.setHeading(0, degrees);

    leftMotor.setPosition(0, degrees);
    <span class="keyword">while</span> (leftMotor.position(degrees) < distance) {
        <span class="keyword">double</span> error = inertialSensor.heading(degrees);
        <span class="keyword">double</span> correction = error * kp;

        leftMotor.spin(forward, 50 - correction, pct);
        rightMotor.spin(forward, 50 + correction, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
            <div class="tip">
                <strong>Tuning `kp`:</strong> The value of `kp` (proportional constant) needs to be tuned for your
                specific robot. A value that is too high will cause over-correction and make the robot "wiggle." A value
                that is too low will not correct the drift enough.
            </div>
        </div>
    </div>
    <div id="page-pid-control" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">PID Control</h1>
        </div>
        <div class="code-section">
            <h3>Bang-Bang Control</h3>
            <p>A simple control method that drives at full speed and then slows down near the target to prevent
                overshooting.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveForwardBangBang</span>(<span class="keyword">int</span> distance) {
    leftMotor.setPosition(0, deg);
    <span class="keyword">while</span>(leftMotor.position(degrees) < distance * <span class="number">0.80</span>) {
        leftMotor.spin(forward, 100, pct);
        rightMotor.spin(forward, 100, pct);
    }
    <span class="keyword">while</span>(leftMotor.position(degrees) < distance) {
        leftMotor.spin(forward, 10, pct);
        rightMotor.spin(forward, 10, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
            <div class="warning">
                <strong>Overshooting:</strong> Bang-Bang can still overshoot, especially with heavier robots or on slick
                surfaces. The 80% threshold may need to be adjusted.
            </div>
        </div>
        <div class="code-section">
            <h3>Proportional Control (Ramping)</h3>
            <p>This code ramps the motor speed up as it starts and ramps it down as it approaches the target, leading to
                smoother movement.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveForwardProp</span>(<span class="keyword">int</span> distance) {
    leftMotor.setPosition(0, degrees);
    <span class="keyword">while</span>(leftMotor.position(degrees) < distance) {
        <span class="keyword">int</span> speed = <span class="number">0</span>;
        <span class="keyword">if</span> (leftMotor.position(degrees) < <span class="number">100</span> && leftMotor.position(degrees) <  distance * <span class="number">0.5</span>) {
            speed = leftMotor.position(degrees) + <span class="number">1</span>;
        } <span class="keyword">else</span> {
            speed = distance - leftMotor.position(degrees);
        }
        leftMotor.spin(forward, speed, pct);
        rightMotor.spin(forward, speed, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
    </div>
    <div id="page-gyro-sensor" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Gyro/Inertial Sensor</h1>
        </div>
        <div class="code-section">
            <h3>Calibrating the Inertial Sensor</h3>
            <p>You must calibrate your inertial sensor before using it in your code to ensure accurate readings.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">int</span> <span class="function">main</span>() {
    <span class="comment">// A global instance of vex::brain used for printing to the brain screen</span>
    vex::<span class="type">brain</span> Brain;
    <span class="comment">// Define a global inertial sensor instance</span>
    <span class="type">inertial</span> <span class="function">inertialSensor</span> = <span class="function">inertial</span>(PORT15);

    <span class="keyword">thread</span> t(<span class="function">brainDisplay</span>); <span class="comment">// Assumes you have a brainDisplay function</span>
    
    inertialSensor.calibrate();
    <span class="comment">// Wait until the calibration is complete</span>
    <span class="keyword">while</span>(inertialSensor.isCalibrating()) {
        wait(100, msec);
    }
    <span class="comment">// Your main program logic starts here...</span>
}</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>Reading the Sensor</h3>
            <p>To use the sensor's value, you can access its heading or rotation attribute.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="comment">// Get the current heading in degrees</span>
<span class="keyword">double</span> currentHeading = inertialSensor.heading(degrees);

<span class="comment">// Print the value to the Brain screen</span>
Brain.Screen.printAt(1, 70, <span class="string">"Heading: %f"</span>, currentHeading);</pre>
            </div>
        </div>
    </div>
    <div id="page-optical-sensor" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Optical/Light Sensor</h1>
        </div>
        <div class="code-section">
            <h3>Line Following</h3>
            <p>A simple line-following function that uses an optical sensor's brightness value to determine if the robot
                is on or off the line.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">goForwardLines</span>(<span class="keyword">int</span> numberToGoTo) {
    <span class="keyword">int</span> numberSeen = <span class="number">0</span>;
    <span class="keyword">while</span>(numberSeen < numberToGoTo) {
        <span class="keyword">while</span>(lineSensor.brightness() > <span class="number">30</span>) {
            leftMotor.spin(forward, 75, pct);
            rightMotor.spin(forward, 75, pct);
        }
        <span class="keyword">while</span>(lineSensor.brightness() < <span class="number">30</span>) {
            leftMotor.spin(forward, 75, pct);
            rightMotor.spin(forward, 75, pct);
        }
        numberSeen++;
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
            <div class="tip">
                <strong>Brightness Threshold:</strong> The value `30` is a placeholder. You need to test your sensor's
                brightness values on and off the line to find the correct threshold for your setup.
            </div>
        </div>
    </div>
    <div id="page-bumper-sensor" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Bumper Sensor</h1>
        </div>
        <div class="code-section">
            <h3>Using a Bumper Sensor</h3>
            <p>Bumper sensors are excellent for detecting collisions or for basic touch-based logic. The `pressing()`
                method returns a boolean (`true`/`false`) value.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">driveUntilBumper</span>() {
    <span class="type">bumper</span> <span class="function">frontBumper</span> = <span class="function">bumper</span>(PORT13);
    
    <span class="keyword">while</span>(frontBumper.pressing() == <span class="keyword">false</span>) {
        leftMotor.spin(forward, 50, pct);
        rightMotor.spin(forward, 50, pct);
    }
    leftMotor.stop();
    rightMotor.stop();
}</pre>
            </div>
        </div>
    </div>
    <div id="page-tank-drive" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Tank Drive</h1>
        </div>
        <div class="code-section">
            <h3>Basic Tank Drive</h3>
            <p>This code allows each joystick on the controller to control one side of the robot, providing independent
                control of the left and right sides.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">tankDrive</span>() {
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        leftMotor.spin(forward, Controller1.AxisA.position(), percent);
        rightMotor.spin(forward, Controller1.AxisD.position(), percent);
        wait(10, msec);
    }
}</pre>
            </div>
        </div>
    </div>
    <div id="page-arcade-drive" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Arcade Drive</h1>
        </div>
        <div class="code-section">
            <h3>Basic Arcade Drive</h3>
            <p>Arcade drive uses a single joystick for both forward/backward and turning motion, which can be more
                intuitive for some users.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">splitDrive</span>() {
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        leftMotor.spin(forward, Controller1.AxisA.position() + Controller1.AxisC.position(), pct);
        rightMotor.spin(forward, Controller1.AxisA.position() - Controller1.AxisC.position(), pct);
        wait(10, msec);
    }
}</pre>
            </div>
            <div class="tip">
                <strong>How it works:</strong> The speed for each motor is calculated by adding or subtracting the
                values from two different joystick axes (one for forward/backward, one for turning).
            </div>
        </div>
    </div>
    <div id="page-arm-control" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Arm Control</h1>
        </div>
        <div class="code-section">
            <h3>Using Buttons for Arm Control</h3>
            <p>This is a robust way to control an arm using button presses, with `else if` statements to ensure only one
                action happens at a time.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">userControl</span>() {
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        <span class="keyword">if</span>(Controller1.ButtonRUp.pressing()) {
            rightArm.spin(forward, 50, pct);
            leftArm.spin(forward, 50, pct);
        } <span class="keyword">else if</span> (Controller1.ButtonRDown.pressing()) {
            rightArm.spin(reverse, 50, pct);
            leftArm.spin(reverse, 50, pct);
        } <span class="keyword">else</span> {
            leftArm.stop(hold);
            rightArm.stop(hold);
        }
        wait(10, msec);
    }
}</pre>
            </div>
            <div class="warning">
                <strong>Common Mistake:</strong> Using two separate `if` statements instead of `if/else if` can cause
                the motors to stop and hold as soon as the button is released, even if the other button is still
                pressed.
            </div>
        </div>
    </div>
    <div id="page-inches-conversion" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Inches to Degrees Conversion</h1>
        </div>
        <div class="code-section">
            <h3>Converting Distance to Motor Rotations</h3>
            <p>This helper function allows you to use real-world measurements (inches) to control your robot's movement.
                You must know your wheel's diameter to use this.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">const</span> <span class="keyword">double</span> WHEEL_DIAMETER = <span class="number">4.0</span>; 
<span class="comment">// Circumference formula: C = πd</span>
<span class="keyword">const</span> <span class="keyword">double</span> WHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * M_PI;

<span class="comment">// A motor's rotation is 360 degrees.</span>
<span class="keyword">double</span> <span class="function">inchesToDegrees</span>(<span class="keyword">double</span> distanceInches) {
    <span class="keyword">double</span> distance = (distanceInches / WHEEL_CIRCUMFERENCE) * <span class="number">360</span>;
    <span class="keyword">return</span> distance;
}</pre>
            </div>
            <div class="tip">
                <strong>Using the function:</strong> Call the function like this: `driveForward(inchesToDegrees(24));`
                to drive exactly 24 inches.
            </div>
        </div>
    </div>
    <div id="page-turn-to-heading" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Turn to Heading</h1>
        </div>
        <div class="code-section">
            <h3>Helper Function: Angle Wrapping</h3>
            <p>This function normalizes an angle to a 0-360 degree range. This is critical for preventing issues with
                the gyro sensor values when turning past 360 degrees.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">double</span> <span class="function">wrapAngle</span>(<span class="keyword">double</span> angle) {
    <span class="keyword">while</span> (angle > <span class="number">360</span>) {
        angle -= <span class="number">360</span>;
    }
    <span class="keyword">while</span> (angle < <span class="number">0</span>) {
        angle += <span class="number">360</span>;
    }
    <span class="keyword">return</span> angle;
}</pre>
            </div>
        </div>
        <div class="code-section">
            <h3>Turn to Heading Function</h3>
            <p>This is an advanced function that uses the wrapped angle and a proportional constant (`kp`) to turn to an
                absolute heading on the field.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">void</span> <span class="function">turnToHeading</span>(<span class="keyword">double</span> targetHeading) {
    <span class="keyword">double</span> kp = <span class="number">0.3</span>;
    targetHeading = <span class="function">wrapAngle</span>(targetHeading);

    <span class="keyword">while</span> (<span class="function">fabs</span>(inertialSensor.heading(degrees) - targetHeading) > <span class="number">2.0</span>) {
        <span class="keyword">double</span> error = inertialSensor.heading(degrees) - targetHeading;
        <span class="keyword">double</span> speed = error * kp;
        leftMotor.spin(forward, speed, pct);
        rightMotor.spin(reverse, speed, pct);
    }
    leftMotor.stop(brake);
    rightMotor.stop(brake);
}</pre>
            </div>
        </div>
    </div>
    <div id="page-competition-template" class="page-view">
        <div class="page-header">
            <button class="back-btn" onclick="showMain()">←</button>
            <h1 class="page-title">Competition Template</h1>
        </div>
        <div class="code-section">
            <h3>Official Competition Code Structure</h3>
            <p>All VEX competition programs must be built using this template. The field control system will call
                `autonomous()` and `usercontrol()` at the appropriate times during the match.</p>
            <div class="code-block">
                <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                <pre><span class="keyword">#include</span> <span class="string">"vex.h"</span>
<span class="keyword">using namespace</span> vex;

<span class="comment">// Define your motors and sensors here...</span>

<span class="keyword">void</span> <span class="function">pre_auton</span>() {
    <span class="comment">// Code to run before autonomous starts (e.g., sensor calibration)</span>
}

<span class="keyword">void</span> <span class="function">autonomous</span>() {
    <span class="comment">// Code to run during the 15-second autonomous period</span>
}

<span class="keyword">void</span> <span class="function">usercontrol</span>() {
    <span class="comment">// Code to run during the driver control period</span>
}

<span class="keyword">int</span> <span class="function">main</span>() {
    Competition.autonomous(<span class="function">autonomous</span>);
    Competition.drivercontrol(<span class="function">usercontrol</span>);
    <span class="function">pre_auton</span>();
    <span class="keyword">while</span>(<span class="keyword">true</span>) {
        wait(100, msec);
    }
}</pre>
            </div>
            <div class="highlight">
                <strong>Important:</strong> You must use this competition template in order to pass inspection and
                participate in a VRC competition.
            </div>
        </div>
    </div>
    <script>
        // Navigation functions
        function showMain(state = true) {
            document.getElementById('mainView').style.display = 'block';
            document.querySelectorAll('.page-view').forEach(page => {
                page.style.display = 'none';
            });
            if (state) {
                history.pushState({ page: 'main' }, 'C++ for Robotics - Topic Guide', location.pathname);
            }
        }
        function showPage(topicId, state = true) {
            document.getElementById('mainView').style.display = 'none';
            document.querySelectorAll('.page-view').forEach(page => {
                page.style.display = 'none';
            });
            const targetPage = document.getElementById(`page-${topicId}`);
            if (targetPage) {
                targetPage.style.display = 'block';
                const topicTitle = document.querySelector(`[data-topic="${topicId}"] .topic-title`).textContent;
                if (state) {
                    history.pushState({ page: topicId }, `C++ for Robotics - ${topicTitle}`, `?topic=${topicId}`);
                }
            } else {
                alert(`${topicId} content coming soon!`);
                showMain();
            }
        }
        // Copy code functionality
        function copyCode(button) {
            const codeBlock = button.nextElementSibling.textContent;
            navigator.clipboard.writeText(codeBlock).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = '#27ae60';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '#3498db';
                }, 2000);
            });
        }
        // Event listeners for topic cards
        document.querySelectorAll('.topic-card').forEach(card => {
            card.addEventListener('click', () => {
                const topicId = card.getAttribute('data-topic');
                showPage(topicId);
            });
        });
        // Enhanced search functionality
        document.getElementById('searchInput').addEventListener('input', function (e) {
            const searchTerm = e.target.value.toLowerCase().trim();
            const cards = document.querySelectorAll('.topic-card');
            const sections = document.querySelectorAll('.category-section');

            cards.forEach(card => {
                const searchContent = card.getAttribute('data-search-content').toLowerCase();
                const matches = searchTerm === '' || searchContent.includes(searchTerm);

                card.style.display = matches ? 'block' : 'none';
                card.style.opacity = matches ? '1' : '0';
            });

            // Hide empty sections
            sections.forEach(section => {
                const visibleCards = section.querySelectorAll('.topic-card[style*="block"], .topic-card:not([style*="none"])');
                const hasVisibleCards = Array.from(visibleCards).some(card => {
                    const style = window.getComputedStyle(card);
                    return style.display !== 'none';
                });
                section.style.display = hasVisibleCards ? 'block' : 'none';
            });
        });
        // Handle initial page load and history navigation
        window.addEventListener('popstate', function (event) {
            if (event.state && event.state.page) {
                if (event.state.page === 'main') {
                    showMain(false);
                } else {
                    showPage(event.state.page, false);
                }
            } else {
                // If there's no state, default to showing the main page
                showMain(false);
            }
        });

        // Check for a topic in the URL on initial load
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const topicId = urlParams.get('topic');
            if (topicId) {
                showPage(topicId, false);
            } else {
                showMain(false);
            }
        });
    </script>
    
</body>

</html>